{"name":"Filer","tagline":"Node-like file system for browsers","body":"###Filer\r\n\r\nFiler is a POSIX-like file system interface for browser-based JavaScript.\r\nThe API is as close to the node.js [fs module](http://nodejs.org/api/fs.html) as possible\r\nwith the following differences:\r\n* No synchronous versions of methods (e.g., `mkdir()` but not `mkdirSync()`).\r\n* No permissions (e.g., no `chown()`, `chmod()`, etc.).\r\n* No support (yet) for `fs.watchFile()`, `fs.unwatchFile()`, `fs.watch()`.\r\n* No support for stream-based operations (e.g., `fs.ReadStream`, `fs.WriteStream`).\r\n\r\n### Contributing\r\n\r\nThe best way to get started is to read through the `Getting Started` and `Example` sections before having a look through the open [issues](https://github.com/js-platform/filer/issues). Some of the issues are marked as `good first bug`, but feel free to contribute to any of the issues there, or open a new one if the thing you want to work on isn't there yet. If you would like to have an issue assigned to you, please send me a message and I'll update it.\r\n\r\nThe build system is based on [grunt](http://gruntjs.com/). To get a working build system\r\ndo the following:\r\n\r\n```\r\nnpm install\r\nnpm install -g grunt-cli\r\n```\r\n\r\nYou can now run the following grunt tasks:\r\n* `grunt check` will run [JSHint](http://www.jshint.com/) on your code (do this before submitting a pull request) to catch errors\r\n* `grunt develop` will create a single file version of the library for testing in `dist/idbfs.js`\r\n* `grunt release` like `develop` but will also create a minified version of the library in `dist/idbfs.min.js`\r\n\r\nOnce you've done some hacking and you'd like to have your work merged, you'll need to make a pull request. If you're patch includes code, make sure to check that all the unit tests pass, including any new tests you wrote. Finally, make sure you add yourself to the `AUTHORS` file.\r\n\r\n#### Tests\r\n\r\nYou can run the tests from the project by opening the `tests` directory in your browser. You can also run them [here](http://js-platform.github.io/idbfs/tests/).\r\n\r\n###Downloading\r\n\r\nPre-built versions of the library are available in the repo:\r\n\r\n* [idbfs.js](https://raw.github.com/js-platform/filer/develop/dist/idbfs.js)\r\n* [idbfs.min.js](https://raw.github.com/js-platform/filer/develop/dist/idbfs.min.js)\r\n\r\n### Getting Started\r\n\r\nIDBFS is partly based on the `fs` module from node.js. The API is asynchronous and most methods require the caller to provide a callback function. Errors are passed to callbacks through the first parameter.\r\n\r\nTo create a new file system or open an existing one, create a new `FileSystem` instance and pass the name of the file system. A new IndexedDB database is created for each file system.\r\n\r\nFor additional documentation, check out the `API Reference` below and have a look through the unit tests for more concrete examples of how things work.\r\n\r\n#### Example\r\n\r\n```javascript\r\nvar fs = new IDBFS.FileSystem();\r\nfs.open('/myfile', 'w+', function(err, fd) {\r\n  if (err) throw err;\r\n  fs.close(fd, function(err) {\r\n    if (err) throw err;\r\n    fs.stat('/myfile', function(err, stats) {\r\n      if (err) throw err;\r\n      console.log('stats: ' + JSON.stringify(stats));\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nAs with node.js, there is no guarantee that file system operations will be executed in the order they are invoked. Ensure proper ordering by chaining operations in callbacks.\r\n\r\n### API Reference\r\n\r\nLike node.js, callbacks for methods that accept them are optional but suggested. The first callback parameter is reserved for passing errors. It will be `null` if no errors occurred and should always be checked.\r\n\r\n#### IDBFS.FileSystem(options, callback)\r\n\r\nFile system constructor, invoked to open an existing file system or create a new one. Accepts two arguments: an `options` object,\r\nand an optional `callback`.  The `options` object can specify a number of optional arguments, including:\r\n* `name`: the name of the file system, defaults to \"local\"\r\n* `flags`: one or more flags to use when creating/opening the file system. Use `'FORMAT'` to force IDBFS to format (i.e., erase) the file system\r\n* `provider`: an explicit storage provider to use for the file system's database context provider.  See below for details\r\n\r\nThe `callback` function indicates when the file system is ready for use. Depending on the storage provider used, this might\r\nbe right away, or could take some time. The callback should expect an `error` argument, which will be null if everything worked.\r\nAlso users should check the file system's `readyState` and `error` properties to make sure it is usable.\r\n\r\n```javascript\r\nvar fs;\r\n\r\nfunction fsReady(err) {\r\n  if(err) throw err;\r\n  // Safe to use fs now...\r\n}\r\n\r\nfs = new IDBFS.FileSystem({\r\n  name: \"my-filesystem\",\r\n  flags: 'FORMAT',\r\n  provider: new IDBFS.FileSystem.providers.Memory()\r\n}, fsReady);\r\n```\r\n\r\n####IDBFS.FileSystem.providers - Storage Providers\r\n\r\nIDBFS can be configured to use a number of different storage providers. The provider object encapsulates all aspects\r\nof data access, making it possible to swap in different backend storage options.  There are currently 4 different\r\nproviders to choose from:\r\n* `FileSystem.providers.IndexedDB()` - uses IndexedDB\r\n* `FileSystem.providers.WebSQL()` - uses WebSQL\r\n* `FileSystem.providers.Fallback()` - attempts to use IndexedDB if possible, falling-back to WebSQL if necessary\r\n* `FileSystem.providers.Memory()` - uses memory (not suitable for data that needs to survive the current session)\r\n\r\nYou can choose your provider when creating a `FileSystem`:\r\n\r\n```javascript\r\nvar FileSystem = IDBFS.FileSystem;\r\nvar providers = FileSystem.providers;\r\n\r\n// Example 1: Use the default provider (currently IndexedDB)\r\nvar fs1 = new FileSystem();\r\n\r\n// Example 2: Explicitly use IndexedDB\r\nvar fs2 = new FileSystem({ provider: new providers.IndexedDB() });\r\n\r\n// Example 3: Use one of IndexedDB or WebSQL, whichever is supported\r\nvar fs3 = new FileSystem({ provider: new providers.Fallback() });\r\n```\r\n\r\nEvery provider has an `isSupported()` method, which returns `true` if the browser supports this provider:\r\n\r\n```javascript\r\nif( IDBFS.FileSystem.providers.WebSQL.isSupported() ) {\r\n  ...\r\n}\r\n```\r\n\r\nYou can also write your own provider if you need a different backend. See the code in `src/providers` for details.\r\n\r\n####IDBFS.Path\r\n\r\nThe node.js [path module](http://nodejs.org/api/path.html) is available via the `IDBFS.Path` object. It is\r\nidentical to the node.js version with the following differences:\r\n* No support for `exits()` or `existsSync()`. Use `fs.stat()` instead.\r\n* No notion of a current working directory in `resolve` (the root dir is used instead)\r\n\r\n```javascript\r\nvar path = IDBFS.Path;\r\nvar dir = path.dirname('/foo/bar/baz/asdf/quux');\r\n// dir is now '/foo/bar/baz/asdf'\r\n\r\nvar base = path.basename('/foo/bar/baz/asdf/quux.html');\r\n// base is now 'quux.html'\r\n\r\nvar ext = path.extname('index.html');\r\n// ext is now '.html'\r\n\r\nvar newpath = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');\r\n// new path is now '/foo/bar/baz/asdf'\r\n```\r\n\r\nFor more info see the docs in the [path module](http://nodejs.org/api/path.html) for a particular method:\r\n* `path.normalize(p)`\r\n* `path.join([path1], [path2], [...])`\r\n* `path.resolve([from ...], to)`\r\n* `path.relative(from, to)`\r\n* `path.dirname(p)`\r\n* `path.basename(p, [ext])`\r\n* `path.extname(p)`\r\n* `path.sep`\r\n* `path.delimiter`\r\n\r\n#### fs.stat(path, callback)\r\n\r\nAsynchronous stat(2). Callback gets `(error, stats)`, where `stats` is an object like\r\n\r\n```\r\n{\r\n  node: <string> // internal node id (unique)\r\n  dev: <string> // file system name\r\n  size: <number> // file size in bytes\r\n  nlinks: <number> // number of links\r\n  atime: <number> // last access time\r\n  mtime: <number> // last modified time\r\n  ctime: <number> // creation time\r\n  type: <string> // file type (FILE, DIRECTORY, ...)\r\n}\r\n```\r\n\r\n#### fs.fstat(fd, callback)\r\n\r\nAsynchronous stat(2). Callback gets `(error, stats)`. See `fs.stat`.\r\n\r\n#### fs.link(srcPath, dstPath, callback)\r\n\r\nAsynchronous link(2). Callback gets no additional arguments.\r\n\r\n#### fs.unlink(path, callback)\r\n\r\nAsynchronous unlink(2). Callback gets no additional arguments.\r\n\r\n#### fs.rename(oldPath, newPath, callback)#\r\n\r\nAsynchronous rename(2). Callback gets no additional arguments.\r\n\r\n#### fs.rmdir(path, callback)\r\n\r\nAsynchronous rmdir(2). Callback gets no additional arguments.\r\n\r\n#### fs.mkdir(path, callback)\r\n\r\nAsynchronous mkdir(2). Callback gets no additional arguments.\r\n\r\n#### fs.close(fd, callback)\r\n\r\nAsynchronous close(2). Callback gets no additional arguments.\r\n\r\n#### fs.open(path, flags, callback)\r\n\r\nAsynchronous open(2). Flags can be\r\n\r\n  * `'r'`: Open file for reading. An exception occurs if the file does not exist.\r\n  * `'r+'`: Open file for reading and writing. An exception occurs if the file does not exist.\r\n  * `'w'`: Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n  * `'w+'`: Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n  * `'a'`: Open file for appending. The file is created if it does not exist.\r\n  * `'a+'`: Open file for reading and appending. The file is created if it does not exist.\r\n\r\nCallback gets `(error, fd)`, where `fd` is the file descriptor.\r\n\r\nUnlike node.js, IDBFS does not accept the optional `mode` parameter since it doesn't yet implement file permissions.\r\n\r\n#### fs.write(fd, buffer, offset, length, position, callback)\r\n\r\nWrite bytes from `buffer` to the file specified by `fd`, where `offset` and `length` describe the part of the buffer to be written. The `position` refers to the offset from the beginning of the file where this data should be written. If `position` is `null`, the data will be written at the current position. See pwrite(2).\r\n\r\nThe callback gets `(error, nbytes)`, where `nbytes` is the number of bytes written.\r\n\r\n#### fs.writeFile(filename, data, [options], callback)\r\n\r\nAsynchronously writes data to a file. `data` can be a string or a buffer, in which case any encoding option is ignored. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"w\" }`. If no encoding is specified, and `data` is a string, the encoding defaults to `'utf8'`.  The callback gets `(error)`.\r\n\r\n```javascript\r\n// Write UTF8 text file\r\nfs.writeFile('/myfile.txt', \"...data...\", function (err) {\r\n  if (err) throw err;\r\n});\r\n\r\n// Write binary file\r\nfs.writeFile('/myfile', buffer, function (err) {\r\n  if (err) throw err;\r\n});\r\n```\r\n\r\n#### fs.read(fd, buffer, offset, length, position, callback)\r\n\r\nRead bytes from the file specified by `fd` into `buffer`, where `offset` and `length` describe the part of the buffer to be used. The `position` refers to the offset from the beginning of the file where this data should be read. If `position` is `null`, the data will be written at the current position. See pread(2).\r\n\r\nThe callback gets `(error, nbytes)`, where `nbytes` is the number of bytes read.\r\n\r\n#### fs.readFile(filename, [options], callback)\r\n\r\nAsynchronously reads the entire contents of a file. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"r\" }`. If no encoding is specified, the raw binary buffer is returned on the callback. The callback gets `(error, data)`, where data is the contents of the file.\r\n\r\n```javascript\r\n// Read UTF8 text file\r\nfs.readFile('/myfile.txt', 'utf8', function (err, data) {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n\r\n// Read binary file\r\nfs.readFile('/myfile.txt', function (err, data) {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n```\r\n\r\n#### fs.lseek(fd, offset, whence, callback)\r\n\r\nAsynchronous lseek(2), where `whence` can be `SET`, `CUR`, or `END`. Callback gets `(error, pos)`, where `pos` is the resulting offset, in bytes, from the beginning of the file.\r\n\r\n#### fs.readdir(path, callback)\r\n\r\nAsynchronous readdir(3). Reads the contents of a directory. Callback gets `(error, files)`, where `files` is an array containing the names of each file in the directory, excluding `.` and `..`.\r\n\r\n#### fs.symlink(srcPath, dstPath, callback)\r\n\r\nAsynchronous symlink(2). Callback gets no additional arguments.\r\n\r\nUnlike node.js, IDBFS does not accept the optional `type` parameter.\r\n\r\n#### fs.readlink(path, callback)\r\n\r\nAsynchronous readlink(2). Callback gets `(error, linkContents)`, where `linkContents` is a string containing the path to which the symbolic link links to.\r\n\r\n#### fs.lstat(path, callback)\r\n\r\nAsynchronous lstat(2). Callback gets `(error, stats)`, See `fs.stat`.\r\n","google":"UA-45767870-2","note":"Don't delete this file! It's used internally to help with page regeneration."}