{"name":"Filer","tagline":"Node-like file system for browsers","body":"[![NPM](https://nodei.co/npm/filer.png?downloads=true&stars=true)](https://nodei.co/npm/filer/)\r\n\r\n###Filer\r\n\r\nFiler is a POSIX-like file system interface for browser-based JavaScript.\r\n\r\n### Contributing\r\n\r\nWant to join the fun? We'd love to have you! See [CONTRIBUTING](CONTRIBUTING.md).\r\n\r\n###Downloading\r\n\r\nPre-built versions of the library are available in the repo:\r\n\r\n* [filer.js](https://raw.github.com/js-platform/filer/develop/dist/filer.js)\r\n* [filer.min.js](https://raw.github.com/js-platform/filer/develop/dist/filer.min.js)\r\n\r\n### Getting Started\r\n\r\nFiler is as close to the node.js [fs module](http://nodejs.org/api/fs.html) as possible,\r\nwith the following differences:\r\n\r\n* No synchronous versions of methods (e.g., `mkdir()` but not `mkdirSync()`).\r\n* No permissions (e.g., no `chown()`, `chmod()`, etc.).\r\n* No support (yet) for `fs.watchFile()`, `fs.unwatchFile()`, `fs.watch()`.\r\n* No support for stream-based operations (e.g., `fs.ReadStream`, `fs.WriteStream`).\r\n\r\nFiler has other features lacking in node.js (e.g., swappable backend\r\nstorage providers, support for encryption and compression, extended attributes, etc).\r\n\r\nLike node.js, the API is asynchronous and most methods expect the caller to provide\r\na callback function (note: like node.js, Filer will supply one if it's missing).\r\nErrors are passed to callbacks through the first parameter.  As with node.js,\r\nthere is no guarantee that file system operations will be executed in the order\r\nthey are invoked. Ensure proper ordering by chaining operations in callbacks.\r\n\r\n### Example\r\n\r\nTo create a new file system or open an existing one, create a new `FileSystem`\r\ninstance.  By default, a new [IndexedDB](https://developer.mozilla.org/en/docs/IndexedDB)\r\ndatabase is created for each file system. The file system can also use other\r\nbackend storage providers, for example [WebSQL](http://en.wikipedia.org/wiki/Web_SQL_Database)\r\nor even RAM (i.e., for temporary storage). See the section on [Storage Providers](#providers).\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nfs.open('/myfile', 'w+', function(err, fd) {\r\n  if (err) throw err;\r\n  fs.close(fd, function(err) {\r\n    if (err) throw err;\r\n    fs.stat('/myfile', function(err, stats) {\r\n      if (err) throw err;\r\n      console.log('stats: ' + JSON.stringify(stats));\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n### API Reference\r\n\r\nLike node.js, callbacks for methods that accept them are optional but suggested (i.e., if\r\nyou omit the callback, errors will be thrown as exceptions). The first callback parameter is\r\nreserved for passing errors. It will be `null` if no errors occurred and should always be checked.\r\n\r\n#### Filer.FileSystem(options, callback) constructor\r\n\r\nFile system constructor, invoked to open an existing file system or create a new one.\r\nAccepts two arguments: an `options` object, and an optional `callback`. The `options`\r\nobject can specify a number of optional arguments, including:\r\n\r\n* `name`: the name of the file system, defaults to `'\"local'`\r\n* `flags`: one or more flags to use when creating/opening the file system. Use `'FORMAT'` to force Filer to format (i.e., erase) the file system\r\n* `provider`: an explicit storage provider to use for the file system's database context provider. See the section on [Storage Providers](#providers).\r\n\r\nThe `callback` function indicates when the file system is ready for use. Depending on the storage provider used, this might\r\nbe right away, or could take some time. The callback should expect an `error` argument, which will be null if everything worked.\r\nAlso users should check the file system's `readyState` and `error` properties to make sure it is usable.\r\n\r\n```javascript\r\nvar fs;\r\n\r\nfunction fsReady(err) {\r\n  if(err) throw err;\r\n  // Safe to use fs now...\r\n}\r\n\r\nfs = new Filer.FileSystem({\r\n  name: \"my-filesystem\",\r\n  flags: 'FORMAT',\r\n  provider: new Filer.FileSystem.providers.Memory()\r\n}, fsReady);\r\n```\r\n\r\nNOTE: if the optional callback argument is not passed to the `FileSystem` constructor,\r\noperations done on the resulting file system will be queued and run in sequence when\r\nit becomes ready.\r\n\r\n####Filer.FileSystem.providers - Storage Providers<a name=\"providers\"></a>\r\n\r\nFiler can be configured to use a number of different storage providers. The provider object encapsulates all aspects\r\nof data access, making it possible to swap in different backend storage options.  There are currently 4 different\r\nproviders to choose from:\r\n\r\n* `FileSystem.providers.IndexedDB()` - uses IndexedDB\r\n* `FileSystem.providers.WebSQL()` - uses WebSQL\r\n* `FileSystem.providers.Fallback()` - attempts to use IndexedDB if possible, falling-back to WebSQL if necessary\r\n* `FileSystem.providers.Memory()` - uses memory (not suitable for data that needs to survive the current session)\r\n\r\nYou can choose your provider when creating a `FileSystem`:\r\n\r\n```javascript\r\nvar FileSystem = Filer.FileSystem;\r\nvar providers = FileSystem.providers;\r\n\r\n// Example 1: Use the default provider (currently IndexedDB)\r\nvar fs1 = new FileSystem();\r\n\r\n// Example 2: Explicitly use IndexedDB\r\nvar fs2 = new FileSystem({ provider: new providers.IndexedDB() });\r\n\r\n// Example 3: Use one of IndexedDB or WebSQL, whichever is supported\r\nvar fs3 = new FileSystem({ provider: new providers.Fallback() });\r\n```\r\n\r\nEvery provider has an `isSupported()` method, which returns `true` if the browser supports this provider:\r\n\r\n```javascript\r\nif( Filer.FileSystem.providers.WebSQL.isSupported() ) {\r\n  // WebSQL provider will work in current environment...\r\n}\r\n```\r\n\r\nYou can also write your own provider if you need a different backend. See the code in `src/providers` for details.\r\n\r\n####Filer.FileSystem.adapters - Adapters for Storage Providers\r\n\r\nFiler based file systems can acquire new functionality by using adapters. These wrapper objects extend the abilities\r\nof storage providers without altering them in anway. An adapter can be used with any provider, and multiple\r\nadapters can be used together in order to compose complex functionality on top of a provider.\r\n\r\nThere are currently 5 adapters available:\r\n\r\n* `FileSystem.adapters.Compression(provider)` - a default compression adapter that uses [Zlib](https://github.com/imaya/zlib.js)\r\n* `FileSystem.adapters.Encryption(passphrase, provider)` - a default encryption adapter that uses [AES encryption](http://code.google.com/p/crypto-js/#AES)\r\n\r\nYou can also pick from other encryption cipher algorithms:\r\n* `FileSystem.adapters.AES(passphrase, provider)` - extends a provider with [AES encryption](http://code.google.com/p/crypto-js/#AES)\r\n* `FileSystem.adapters.TripleDES(passphrase, provider)` - extends a provider with [TripleDES encryption](http://code.google.com/p/crypto-js/#DES,_Triple_DES)\r\n* `FileSystem.adapters.Rabbit(passphrase, provider)` - extends a provider with [Rabbit encryption](http://code.google.com/p/crypto-js/#Rabbit)\r\n\r\n```javascript\r\nvar FileSystem = Filer.FileSystem;\r\nvar providers = FileSystem.providers;\r\nvar adapters = FileSystem.adapters;\r\n\r\n// Create a WebSQL-based, Encrypted, Compressed File System by\r\n// composing a provider and adatpers.\r\nvar webSQLProvider = new providers.WebSQL();\r\nvar encryptionAdatper = new adapters.Encryption('super-secret-passphrase', webSQLProvider);\r\nvar compressionAdatper = new adatpers.Compression(encryptionAdapter);\r\nvar fs = new FileSystem({ provider: compressionAdapter });\r\n```\r\n\r\nYou can also write your own adapter if you need to add new capabilities to the providers. Adapters share the same\r\ninterface as providers.  See the code in `src/providers` and `src/adapters` for many examples.\r\n\r\n####Filer.Path\r\n\r\nThe node.js [path module](http://nodejs.org/api/path.html) is available via the `Filer.Path` object. It is\r\nidentical to the node.js version with the following differences:\r\n* No support for `exits()` or `existsSync()`. Use `fs.stat()` instead.\r\n* No notion of a current working directory in `resolve` (the root dir is used instead)\r\n\r\n```javascript\r\nvar path = Filer.Path;\r\nvar dir = path.dirname('/foo/bar/baz/asdf/quux');\r\n// dir is now '/foo/bar/baz/asdf'\r\n\r\nvar base = path.basename('/foo/bar/baz/asdf/quux.html');\r\n// base is now 'quux.html'\r\n\r\nvar ext = path.extname('index.html');\r\n// ext is now '.html'\r\n\r\nvar newpath = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');\r\n// new path is now '/foo/bar/baz/asdf'\r\n```\r\n\r\nFor more info see the docs in the [path module](http://nodejs.org/api/path.html) for a particular method:\r\n* `path.normalize(p)`\r\n* `path.join([path1], [path2], [...])`\r\n* `path.resolve([from ...], to)`\r\n* `path.relative(from, to)`\r\n* `path.dirname(p)`\r\n* `path.basename(p, [ext])`\r\n* `path.extname(p)`\r\n* `path.sep`\r\n* `path.delimiter`\r\n\r\n###FileSystem Instance Methods\r\n\r\nOnce a `FileSystem` is created, it has the following methods. NOTE: code examples below assume\r\na `FileSystem` instance named `fs` has been created like so:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\n```\r\n\r\n* [fs.rename(oldPath, newPath, callback)](#rename)\r\n* [fs.ftruncate(fd, len, callback)](#ftruncate)\r\n* [fs.truncate(path, len, callback)](#truncate)\r\n* [fs.stat(path, callback)](#stat)\r\n* [fs.fstat(fd, callback)](#fstat)\r\n* [fs.lstat(path, callback)](#lstat)\r\n* [fs.link(srcpath, dstpath, callback)](#link)\r\n* [fs.symlink(srcpath, dstpath, [type], callback)](#symlink)\r\n* [fs.readlink(path, callback)](#readlink)\r\n* [fs.realpath(path, [cache], callback)](#realpath)\r\n* [fs.unlink(path, callback)](#unlink)\r\n* [fs.rmdir(path, callback)](#rmdir)\r\n* [fs.mkdir(path, [mode], callback)](#mkdir)\r\n* [fs.readdir(path, callback)](#readdir)\r\n* [fs.close(fd, callback)](#close)\r\n* [fs.open(path, flags, [mode], callback)](#open)\r\n* [fs.utimes(path, atime, mtime, callback)](#utimes)\r\n* [fs.futimes(fd, atime, mtime, callback)](#fsutimes)\r\n* [fs.fsync(fd, callback)](#fsync)\r\n* [fs.write(fd, buffer, offset, length, position, callback)](#write)\r\n* [fs.read(fd, buffer, offset, length, position, callback)](#read)\r\n* [fs.readFile(filename, [options], callback)](#readFile)\r\n* [fs.writeFile(filename, data, [options], callback)](#writeFile)\r\n* [fs.appendFile(filename, data, [options], callback)](#appendFile)\r\n* [fs.setxattr(path, name, value, [flag], callback)](#setxattr)\r\n* [fs.fsetxattr(fd, name, value, [flag], callback)](#fsetxattr)\r\n* [fs.getxattr(path, name, callback)](#getxattr)\r\n* [fs.fgetxattr(fd, name, callback)](#fgetxattr)\r\n* [fs.removexattr(path, name, callback)](#removexattr)\r\n* [fs.fremovexattr(fd, name, callback)](#fremovexattr)\r\n\r\n#### fs.rename(oldPath, newPath, callback)<a name=\"rename\"></a>\r\n\r\nRenames the file at `oldPath` to `newPath`. Asynchronous [rename(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html).\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Rename myfile.txt to myfile.bak\r\nfs.rename(\"/myfile.txt\", \"/myfile.bak\", function(err) {\r\n  if(err) throw err;\r\n  // myfile.txt is now myfile.bak\r\n});\r\n```\r\n\r\n#### fs.ftruncate(fd, len, callback)<a name=\"ftruncate\"></a>\r\n\r\nChange the size of the file represented by the open file descriptor `fd` to be length\r\n`len` bytes. Asynchronous [ftruncate(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/ftruncate.html).\r\nIf the file is larger than `len`, the extra bytes will be discarded; if smaller, its size will\r\nbe increased, and the extended area will appear as if it were zero-filled. See also [fs.truncate()](#truncate).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file, shrink it, expand it.\r\nvar buffer = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n  fs.write(fd, buffer, 0, buffer.length, 0, function(err, result) {\r\n    if(err) throw error;\r\n      fs.ftruncate(fd, 3, function(err) {\r\n        if(err) throw error;\r\n        // /myfile is now 3 bytes in length, rest of data discarded\r\n\r\n        fs.ftruncate(fd, 50, function(err) {\r\n          if(err) throw error;\r\n          // /myfile is now 50 bytes in length, with zero padding at end\r\n\r\n          fs.close(fd);\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n#### fs.truncate(path, len, callback)<a name=\"truncate\"></a>\r\n\r\nChange the size of the file at `path` to be length `len` bytes. Asynchronous [truncate(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/truncate.html). If the file is larger than `len`, the extra bytes will be discarded; if smaller, its size will\r\nbe increased, and the extended area will appear as if it were zero-filled. See also [fs.ftruncate()](#ftruncate).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file, shrink it, expand it.\r\nvar buffer = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n  fs.write(fd, buffer, 0, buffer.length, 0, function(err, result) {\r\n    if(err) throw error;\r\n    fs.close(fd, function(err) {\r\n      if(err) throw error;\r\n\r\n      fs.truncate('/myfile', 3, function(err) {\r\n        if(err) throw error;\r\n        // /myfile is now 3 bytes in length, rest of data discarded\r\n\r\n        fs.truncate('/myfile', 50, function(err) {\r\n          if(err) throw error;\r\n          // /myfile is now 50 bytes in length, with zero padding at end\r\n\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n#### fs.stat(path, callback)<a name=\"stat\"></a>\r\n\r\nObtain file status about the file at `path`. Asynchronous [stat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html).\r\nCallback gets `(error, stats)`, where `stats` is an object with the following properties:\r\n\r\n```\r\n{\r\n  node: <string>   // internal node id (unique)\r\n  dev: <string>    // file system name\r\n  size: <number>   // file size in bytes\r\n  nlinks: <number> // number of links\r\n  atime: <number>  // last access time\r\n  mtime: <number>  // last modified time\r\n  ctime: <number>  // creation time\r\n  type: <string>   // file type (FILE, DIRECTORY, SYMLINK)\r\n}\r\n```\r\n\r\nIf the file at `path` is a symbolik link, the file to which it links will be used instead.\r\nTo get the status of a symbolic link file, use [fs.lstat()](#lstat) instead.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Check if a directory exists\r\nfunction dirExists(path, callback) {\r\n  fs.stat(path, function(err, stats) {\r\n    if(err) return callback(err);\r\n    var exists = stats.type === \"DIRECTORY\";\r\n    callback(null, exists);\r\n  });\r\n};\r\n\r\n// Get the size of a file in KB\r\nfunction fileSize(path, callback) {\r\n  fs.stat(path, function(err, stats) {\r\n    if(err) return callback(err);\r\n    var kb = stats.size / 1000;\r\n    callback(null, kb);\r\n  });\r\n}\r\n```\r\n\r\n#### fs.fstat(fd, callback)<a name=\"fstat\"></a>\r\n\r\nObtain information about the open file known by the file descriptor `fd`.\r\nAsynchronous [fstat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/fstat.html).\r\nCallback gets `(error, stats)`. `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\nspecified by the open file descriptor `fd` instead of a path.  See also [fs.stat](#stat)\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open(\"/file.txt\", \"r\", function(err, fd) {\r\n  if(err) throw err;\r\n  fs.fstat(fd, function(err, stats) {\r\n    if(err) throw err;\r\n    // do something with stats object\r\n    // ...\r\n    fs.close(fd);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.lstat(path, callback)<a name=\"lstat\"></a>\r\n\r\nObtain information about the file at `path` (i.e., the symbolic link file itself) vs.\r\nthe destination file to which it links. Asynchronous [lstat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/lstat.html).\r\nCallback gets `(error, stats)`. See also [fs.stat](#stat).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a symbolic link, /data/logs/current to /data/logs/august\r\n// and get info about the symbolic link file, and linked file.\r\nfs.link(\"/data/logs/august\", \"/data/logs/current\", function(err) {\r\n  if(err) throw err;\r\n\r\n  // Get status of linked file, /data/logs/august\r\n  fs.stat(\"/data/logs/current\", function(err, stats) {\r\n    if(err) throw err;\r\n    // Size of /data/logs/august\r\n    var size = stats.size;\r\n  });\r\n\r\n  // Get status of symbolic link file itself\r\n  fs.lstat(\"/data/logs/current\", function(err, stats) {\r\n    if(err) throw err;\r\n    // Size of /data/logs/current\r\n    var size = stats.size;\r\n  });\r\n});\r\n````\r\n\r\n#### fs.link(srcPath, dstPath, callback)<a name=\"link\"></a>\r\n\r\nCreate a (hard) link to the file at `srcPath` named `dstPath`. Asynchronous [link(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/link.html). Callback gets no additional arguments. Links are directory entries that point to the same file node.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.link('/logs/august.log', '/logs/current', function(err) {\r\n  if(err) throw err;\r\n  fs.readFile('/logs/current', 'utf8', function(err, data) {\r\n    // data is the contents of /logs/august.log\r\n    var currentLog = data;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.symlink(srcPath, dstPath, [type], callback)<a name=\"symlink\"></a>\r\n\r\nCreate a symbolic link to the file at `dstPath` containing the path `srcPath`. Asynchronous [symlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/symlink.html). Callback gets no additional arguments.\r\nSymbolic links are files that point to other paths.\r\n\r\nNOTE: Filer allows for, but ignores the optional `type` parameter used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.symlink('/logs/august.log', '/logs/current', function(err) {\r\n  if(err) throw err;\r\n  fs.readFile('/logs/current', 'utf8', function(err, data) {\r\n    // data is the contents of /logs/august.log\r\n    var currentLog = data;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readlink(path, callback)<a name=\"readlink\"></a>\r\n\r\nReads the contents of a symbolic link. Asynchronous [readlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/readlink.html). Callback gets `(error, linkContents)`, where `linkContents` is a string containing the symbolic link's link path.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.symlink('/logs/august.log', '/logs/current', function(error) {\r\n  if(error) throw error;\r\n\r\n  fs.readlink('/logs/current', function(error, linkContents) {\r\n    // linkContents is now '/logs/august.log'\r\n  });\r\n});\r\n```\r\n\r\n#### fs.realpath(path, [cache], callback)<a name=\"realpath\"></a>\r\n\r\nNOTE: Not yet implemented, see https://github.com/js-platform/filer/issues/85\r\n\r\n#### fs.unlink(path, callback)<a name=\"unlink\"></a>\r\n\r\nRemoves the directory entry located at `path`. Asynchronous [unlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/unlink.html).\r\nCallback gets no additional arguments. If `path` names a symbolic link, the symbolic link will be removed\r\n(i.e., not the linked file). Otherwise, the filed named by `path` will be removed (i.e., deleted).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Delete regular file /backup.old\r\nfs.unlink('/backup.old', function(err) {\r\n  if(err) throw err;\r\n  // /backup.old is now removed\r\n});\r\n```\r\n\r\n#### fs.rmdir(path, callback)<a name=\"rmdir\"></a>\r\n\r\nRemoves the directory at `path`. Asynchronous [rmdir(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/rmdir.html).\r\nCallback gets no additional arguments. The operation will fail if the directory at `path` is not empty.\r\n\r\nExample:\r\n\r\n```javascript\r\n/**\r\n * Given the following dir structure, remove docs/\r\n *  /docs\r\n *    a.txt\r\n */\r\n\r\n// Start by deleting the files in docs/, then remove docs/\r\nfs.unlink('/docs/a.txt', function(err) {\r\n  if(err) throw err;\r\n  fs.rmdir('/docs', function(err) {\r\n    if(err) throw err;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.mkdir(path, [mode], callback)<a name=\"mkdir\"></a>\r\n\r\nMakes a directory with name supplied in `path` argument. Asynchronous [mkdir(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/mkdir.html). Callback gets no additional arguments.\r\n\r\nNOTE: Filer allows for, but ignores the optional `mode` argument used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create /home and then /home/carl directories\r\nfs.mkdir('/home', function(err) {\r\n  if(err) throw err;\r\n\r\n  fs.mkdir('/home/carl', function(err) {\r\n    if(err) throw err;\r\n    // directory /home/carl now exists\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readdir(path, callback)<a name=\"readdir\"></a>\r\n\r\nReads the contents of a directory. Asynchronous [readdir(3)](http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir.html).\r\nCallback gets `(error, files)`, where `files` is an array containing the names of each directory entry (i.e., file, directory, link) in the directory, excluding `.` and `..`.\r\n\r\nExample:\r\n\r\n```javascript\r\n/**\r\n * Given the following dir structure:\r\n *  /docs\r\n *    a.txt\r\n *    b.txt\r\n *    c/\r\n */\r\nfs.readdir('/docs', function(err, files) {\r\n  if(err) throw err;\r\n  // files now contains ['a.txt', 'b.txt', 'c']\r\n});\r\n```\r\n\r\n#### fs.close(fd, callback)<a name=\"close\"></a>\r\n\r\nCloses a file descriptor. Asynchronous [close(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/close.html).\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Do something with open file descriptor `fd`\r\n\r\n  // Close file descriptor when done\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.open(path, flags, [mode], callback)<a name=\"open\"></a>\r\n\r\nOpens a file. Asynchronous [open(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html).\r\nCallback gets `(error, fd)`, where `fd` is the file descriptor. The `flags` argument can be:\r\n\r\n* `'r'`: Open file for reading. An exception occurs if the file does not exist.\r\n* `'r+'`: Open file for reading and writing. An exception occurs if the file does not exist.\r\n* `'w'`: Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n* `'w+'`: Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n* `'a'`: Open file for appending. The file is created if it does not exist.\r\n* `'a+'`: Open file for reading and appending. The file is created if it does not exist.\r\n\r\nNOTE: Filer allows for, but ignores the optional `mode` argument used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Do something with open file descriptor `fd`\r\n\r\n  // Close file descriptor when done\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.utimes(path, atime, mtime, callback)<a name=\"utimes\"></a>\r\n\r\nChanges the file timestamps for the file given at path `path`. Asynchronous [utimes(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/utimes.html). Callback gets no additional arguments. Both `atime` (access time) and `mtime` (modified time) arguments should be a JavaScript Date.\r\n\r\nExample:\r\n\r\n```javascript\r\nvar now = Date.now();\r\nfs.utimes('/myfile.txt', now, now, function(err) {\r\n  if(err) throw err;\r\n  // Access Time and Modified Time for /myfile.txt are now updated\r\n});\r\n```\r\n\r\n#### fs.futimes(fd, atime, mtime, callback)<a name=\"futimes\"></a>\r\n\r\nChanges the file timestamps for the open file represented by the file descriptor `fd`. Asynchronous [utimes(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/utimes.html). Callback gets no additional arguments. Both `atime` (access time) and `mtime` (modified time) arguments should be a JavaScript Date.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile.txt', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  var now = Date.now();\r\n  fs.futimes(fd, now, now, function(err) {\r\n    if(err) throw err;\r\n\r\n    // Access Time and Modified Time for /myfile.txt are now updated\r\n\r\n    fs.close(fd);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.fsync(fd, callback)<a name=\"fsync\"></a>\r\n\r\nNOTE: Not yet implemented, see https://github.com/js-platform/filer/issues/87\r\n\r\n#### fs.write(fd, buffer, offset, length, position, callback)<a name=\"write\"></a>\r\n\r\nWrites bytes from `buffer` to the file specified by `fd`. Asynchronous [write(2), pwrite(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/write.html). The `offset` and `length` arguments describe the part of the buffer to be written. The `position` refers to the offset from the beginning of the file where this data should be written. If `position` is `null`, the data will be written at the current position. The callback gets `(error, nbytes)`, where `nbytes` is the number of bytes written.\r\n\r\nNOTE: Filer currently writes the entire buffer in a single operation. However, future versions may do it in chunks.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file with the following bytes.\r\nvar buffer = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  var expected = buffer.length, written = 0;\r\n  function writeBytes(offset, position, length) {\r\n    length = length || buffer.length - written;\r\n\r\n    fs.write(fd, buffer, offset, length, position, function(err, nbytes) {\r\n      if(err) throw error;\r\n\r\n      // nbytes is now the number of bytes written, between 0 and buffer.length.\r\n      // See if we still have more bytes to write.\r\n      written += nbytes;\r\n\r\n      if(written < expected)\r\n        writeBytes(written, null);\r\n      else\r\n        fs.close(fd);\r\n    });\r\n  }\r\n\r\n  writeBytes(0, 0);\r\n});\r\n```\r\n\r\n#### fs.read(fd, buffer, offset, length, position, callback)<a name=\"read\"></a>\r\n\r\nRead bytes from the file specified by `fd` into `buffer`. Asynchronous [read(2), pread(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html). The `offset` and `length` arguments describe the part of the buffer to be used. The `position` refers to the offset from the beginning of the file where this data should be read. If `position` is `null`, the data will be written at the current position. The callback gets `(error, nbytes)`, where `nbytes` is the number of bytes read.\r\n\r\nNOTE: Filer currently reads into the buffer in a single operation. However, future versions may do it in chunks.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Determine size of file\r\n  fs.fstat(fd, function(err, stats) {\r\n    if(err) throw error;\r\n\r\n    // Create a buffer large enough to hold the file's contents\r\n    var nbytes = expected = stats.size;\r\n    var buffer = new Uint8Array(nbytes);\r\n    var read = 0;\r\n\r\n    function readBytes(offset, position, length) {\r\n      length = length || buffer.length - read;\r\n\r\n      fs.read(fd, buffer, offset, length, position, function(err, nbytes) {\r\n        if(err) throw error;\r\n\r\n        // nbytes is now the number of bytes read, between 0 and buffer.length.\r\n        // See if we still have more bytes to read.\r\n        read += nbytes;\r\n\r\n        if(read < expected)\r\n          readBytes(read, null);\r\n        else\r\n          fs.close(fd);\r\n      });\r\n    }\r\n\r\n    readBytes(0, 0);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readFile(filename, [options], callback)<a name=\"readFile\"></a>\r\n\r\nReads the entire contents of a file. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"r\" }`. If no encoding is specified, the raw binary buffer is returned via the callback. The callback gets `(error, data)`, where data is the contents of the file.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Read UTF8 text file\r\nfs.readFile('/myfile.txt', 'utf8', function (err, data) {\r\n  if (err) throw err;\r\n  // data is now the contents of /myfile.txt (i.e., a String)\r\n});\r\n\r\n// Read binary file\r\nfs.readFile('/myfile.txt', function (err, data) {\r\n  if (err) throw err;\r\n  // data is now the contents of /myfile.txt (i.e., an Uint8Array of bytes)\r\n});\r\n```\r\n\r\n#### fs.writeFile(filename, data, [options], callback)<a name=\"writeFile\"></a>\r\n\r\nWrites data to a file. `data` can be a string or a buffer, in which case any encoding option is ignored. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"w\" }`. If no encoding is specified, and `data` is a string, the encoding defaults to `'utf8'`.  The callback gets `(error)`.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Write UTF8 text file\r\nfs.writeFile('/myfile.txt', \"...data...\", function (err) {\r\n  if (err) throw err;\r\n});\r\n\r\n// Write binary file\r\nvar buffer = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\r\nfs.writeFile('/myfile', buffer, function (err) {\r\n  if (err) throw err;\r\n});\r\n```\r\n\r\n#### fs.appendFile(filename, data, [options], callback)<a name=\"appendFile\"></a>\r\n\r\nNOTE: Not yet implemented, see https://github.com/js-platform/filer/issues/88\r\n\r\n#### fs.setxattr(path, name, value, [flag], callback)<a name=\"setxattr\"></a>\r\n\r\nSets an extended attribute of a file or directory named `path`. Asynchronous [setxattr(2)](http://man7.org/linux/man-pages/man2/setxattr.2.html).\r\nThe optional `flag` parameter can be set to the following:\r\n* `XATTR_CREATE`: ensures that the extended attribute with the given name will be new and not previously set. If an attribute with the given name already exists, it will return an `EExists` error to the callback.\r\n* `XATTR_REPLACE`: ensures that an extended attribute with the given name already exists. If an attribute with the given name does not exist, it will return an `ENoAttr` error to the callback.\r\n\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.writeFile('/myfile', 'data', function(err) {\r\n  if(err) throw err;\r\n\r\n  // Set a simple extended attribute on /myfile\r\n  fs.setxattr('/myfile', 'extra', 'some-information', function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra='some-information'\r\n  });\r\n\r\n  // Set a complex object attribute on /myfile\r\n  fs.setxattr('/myfile', 'extra-complex', { key1: 'value1', key2: 103 }, function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra={ key1: 'value1', key2: 103 }\r\n  });\r\n});\r\n```\r\n\r\n#### fs.fsetxattr(fd, name, value, [flag], callback)<a name=\"fsetxattr\"></a>\r\n\r\nSets an extended attribute of the file represented by the open file descriptor `fd`. Asynchronous [setxattr(2)](http://man7.org/linux/man-pages/man2/setxattr.2.html).  See `fs.setxattr` for more details. Callback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  // Set a simple extended attribute on fd for /myfile\r\n  fs.fsetxattr(fd, 'extra', 'some-information', function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra='some-information'\r\n  });\r\n\r\n  // Set a complex object attribute on fd for /myfile\r\n  fs.fsetxattr(fd, 'extra-complex', { key1: 'value1', key2: 103 }, function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra={ key1: 'value1', key2: 103 }\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.getxattr(path, name, callback)<a name=\"getxattr\"></a>\r\n\r\nGets an extended attribute value for a file or directory. Asynchronous [getxattr(2)](http://man7.org/linux/man-pages/man2/getxattr.2.html).\r\nCallback gets `(error, value)`, where `value` is the value for the extended attribute named `name`.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Get the value of the extended attribute on /myfile named `extra`\r\nfs.getxattr('/myfile', 'extra', function(err, value) {\r\n  if(err) throw err;\r\n\r\n  // `value` is now the value of the extended attribute named `extra` for /myfile\r\n});\r\n```\r\n\r\n#### fs.fgetxattr(fd, name, callback)<a name=\"fgetxattr\"></a>\r\n\r\nGets an extended attribute value for the file represented by the open file descriptor `fd`.\r\nAsynchronous [getxattr(2)](http://man7.org/linux/man-pages/man2/getxattr.2.html).\r\nSee `fs.getxattr` for more details. Callback gets `(error, value)`, where `value` is the value for the extended attribute named `name`.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Get the value of the extended attribute on /myfile named `extra`\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  fs.fgetxattr(fd, 'extra', function(err, value) {\r\n    if(err) throw err;\r\n\r\n    // `value` is now the value of the extended attribute named `extra` for /myfile\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.removexattr(path, name, callback)<a name=\"removexattr\"></a>\r\n\r\nRemoves the extended attribute identified by `name` for the file given at `path`. Asynchronous [removexattr(2)](http://man7.org/linux/man-pages/man2/removexattr.2.html). Callback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Remove an extended attribute on /myfile\r\nfs.removexattr('/myfile', 'extra', function(err) {\r\n  if(err) throw err;\r\n\r\n  // The `extra` extended attribute on /myfile is now gone\r\n});\r\n```\r\n\r\n#### fs.fremovexattr(fd, name, callback)<a name=\"fremovexattr\"></a>\r\n\r\nRemoves the extended attribute identified by `name` for the file represented by the open file descriptor `fd`.\r\nAsynchronous [removexattr(2)](http://man7.org/linux/man-pages/man2/removexattr.2.html). See `fs.removexattr` for more details.\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Remove an extended attribute on /myfile\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  fs.fremovexattr(fd, 'extra', function(err) {\r\n    if(err) throw err;\r\n\r\n    // The `extra` extended attribute on /myfile is now gone\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n","google":"UA-45767870-2","note":"Don't delete this file! It's used internally to help with page regeneration."}